#' Filters OTUs Generated by PCR or Sequencing Error from Count Tables
#'
#' Using propr and ALDEx2 functions, filtR removes OTUs generated by PCR and sequencing error from count tables. There are two filtering parameters. One is rho, which is a measure of beta-association between two OTUs. Each individual OTU, for the most part, should lack association with other OTUs because they are independent entities. The other filtering parameter is difference in centered log ratio. If an OTU is derived from an error in PCR or sequencing, it is expected to have a much lower abundance than the OTU it associates with. The input for this package is a count table with the columns as samples and the rows as OTUs/ASVs. The output is a count table with the error-derived OTUs removed.
#' @param count_file Input your saved count file.
#' @param rho_CO Input your rho value cutoff. Range of 0 to 1. Higher value results in a tighter filter with less OTUs being discarded. Defaults to 0.7.
#' @param clr_CO Input your centered log ratio difference cutoff. Higher value results in a tighter filter with less OTUs being discarded Defaults to 5.
#' @return Count table with error-derived OTUs removed.
#' @export
#' @examples
#' function(count_file='SRP058027_taxonomy_abundances_SSU_v4.1.tsv', rho_CO=0.7, clr_CO=5)
filtR <- function(count_file, rho_CO=0.7, clr_CO=5) {
  m <- read.table(count_file)
  taxcol <- c()
  for(i in 1:ncol(m)) {
    if(class(m[,i]) == "factor") {
    taxcol <- c(taxcol, i)
    }
    else {
      next
    }
  }
  if(length(taxcol) == 0) {
    m.n0 <- m
  }
  else {
    m.n0 <- m[,-taxcol]
  }
  m.clr <- aldex.clr(m.n0, conds = rep("x", ncol(m.n0)))
  m.propr <- aldex2propr(m.clr)
  m.propr <- m.propr[">", rho_CO]
  if(length(m.propr@pairs) == 0) {
    stop('Rho cutoff resulted in no pairs of associated features being identified. Consider relaxing the rho cutoff.', call. = FALSE)
    }
  else {
    m.propr.simp <- simplify(m.propr)
    }
  rhopairs <- data.frame()
  coords <- for(i in m.propr.simp@pairs) {
       if(i %% ncol(m.propr.simp@logratio) == 0) {
           rhopairs <- rbind(rhopairs, c(ncol(m.propr.simp@logratio), i %/% ncol(m.propr.simp@logratio)))
       }
       else {
           rhopairs <- rbind(rhopairs, c(i %% ncol(m.propr.simp@logratio) , i %/% ncol(m.propr.simp@logratio) +1))
       }
  }
  clrmeans <- colMeans(m.propr.simp@logratio)
  clrmeans <- as.vector(clrmeans)
  clrdiffer <- function(x) {
    clrmeans[rhopairs[,1]] - clrmeans[rhopairs[,2]]
  }
  clrdiff <- sapply(1, clrdiffer)
  taxpairs <- as.numeric(colnames(m.propr.simp@logratio))
  taxa <- m[taxpairs,1]
  taxa <- as.character(taxa)
  final1 <- cbind(colnames(m.propr.simp@logratio[,rhopairs[,1]]), colnames(m.propr.simp@logratio[,rhopairs[,2]]), format(round(m.propr.simp@matrix[m.propr.simp@pairs], 4), nsamll=4), format(round(clrdiff, 4), nsmall=4), taxa[rhopairs[,1]], taxa[rhopairs[,2]])
  colnames(final1) <- c("OTU/ASV_1", "OTU/ASV_2", "Rho_Value", "CLR_Difference", "Taxonomy_of_OTU/ASV_1", "Taxonomy_of_OTU/ASV 2")
  final5 <- final1[which(abs(as.numeric(final1[,4])) > clr_CO),]
  m.neg <- as.numeric(final5[which(as.numeric(final5[,4]) < 0), 1])
  m.pos <- as.numeric(final5[which(as.numeric(final5[,4]) > 0), 2])
  m.remove <- unique(sort(c(m.pos, m.neg)))
  if(length(m.remove) == 0) {
    stop('CLR cutoff resulted in no OTUs/ASVs being discarded. Consider relaxing the CLR cutoff.', call. = FALSE)
  }
  print(paste('Number of OTUs/ASVs filtered from count table: ', length(m.remove)))
  filtR_table <- m[-m.remove,]
  return(filtR_table)
}
